<root><title>080_Formal_Grammars</title><anchors id="page1"></anchors><p><span>CS143</span></p><p><span>Handout 08</span></p><p><span>Summer 2011</span></p><p><span>June 24</span><span>th</span><span>, 2011</span></p><p><span style="bold">Formal Grammars</span></p><p><span>Handout written by Maggie Johnson and Julie Zelenski.</span></p><p><span style="bold">What is a grammar?</span></p><p><span>A</span><span style="italic"> grammar</span><span> is a powerful tool for describing and analyzing languages. It is a set of rules by which valid sentences in a language are constructed. Here’s a trivial example of English grammar:</span></p><table columns="3" rows="7"><row><cell><p><span style="bold">sentence</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span style="bold">&lt;subject&gt; &lt;verb-phrase&gt; &lt;object&gt;</span></p></cell></row><row><cell><p><span style="bold">subject</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>This | Computers | I</span></p></cell></row><row><cell><p><span style="bold">verb-phrase</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span style="bold">&lt;adverb&gt; &lt;verb&gt;</span><span> |</span><span style="bold"> &lt;verb&gt;</span></p></cell></row><row><cell><p><span style="bold">adverb</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>never</span></p></cell></row><row><cell><p><span style="bold">verb</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>is | run | am | tell</span></p></cell></row><row><cell><p><span style="bold">object</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>the</span><span style="bold"> &lt;noun&gt;</span><span> |a</span><span style="bold"> &lt;noun&gt;</span><span> |</span><span style="bold"> &lt;noun&gt;</span></p></cell></row><row><cell><p><span style="bold">noun</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>university | world | cheese | lies</span></p></cell></row></table><p><span>Using the above rules or</span><span style="italic"> productions</span><span>, we can derive simple sentences such as these:</span></p><p><span>This is a university.</span></p><p><span>Computers run the world.</span></p><p><span>I am the cheese.</span></p><p><span>I never tell lies.</span></p><p><span>Here is a</span><span style="italic"> leftmost derivation</span><span> of the first sentence using these productions.</span></p><p><span style="bold">sentence</span></p><p><span>–&gt; –&gt; –&gt; –&gt; –&gt; –&gt;</span></p><p><span style="bold">&lt;subject&gt; &lt;verb-phrase&gt; &lt;object&gt;</span><span> This</span><span style="bold"> &lt;verb-phrase&gt; &lt;object&gt;</span></p><p><span>This</span><span style="bold"> &lt;verb&gt; &lt;object&gt;</span></p><p><span>This is</span><span style="bold"> &lt;object&gt;</span></p><p><span>This is a</span><span style="bold"> &lt;noun&gt; </span><br /><span>This is a university</span></p><p><span>In addition to several reasonable sentences, we can also derive nonsense like "Computers run cheese" and "This am a lies". These sentences don't make semantic sense, but they are syntactically correct because they are of the sequence of subject, verb­phrase, and object. Formal grammars are a tool for</span><span style="italic"> syntax</span><span>, not</span><span style="italic"> semantics</span><span>. We worry about semantics at a later point in the compiling process. In the syntax analysis phase, we verify structure, not meaning.</span></p><anchors id="page2"></anchors><p><span style="bold">Vocabulary</span></p><p><span>We need to review some definitions before we can proceed:</span></p><table columns="3" rows="12"><row><cell><p><span style="italic">grammar</span></p></cell><cell row_span="10" /><cell><p><span>a set of rules by which valid sentences in a language are constructed.</span></p></cell></row><row><cell><p><span style="italic">nonterminal</span></p></cell><cell><p><span>a grammar symbol that can be replaced/expanded to a sequence of symbols.</span></p></cell></row><row><cell><p><span style="italic">terminal</span></p></cell><cell><p><span>an actual word in a language; these are the symbols in a grammar that cannot be replaced by anything else. "terminal" is supposed to conjure up the idea that it is a dead­end—no further expansion is possible.</span></p></cell></row><row><cell><p><span style="italic">production</span></p></cell><cell><p><span>a grammar rule that describes how to replace/exchange symbols. The general form of a production for a nonterminal is:</span></p></cell></row><row><cell row_span="2" /><cell><p><span>X –&gt;Y</span><span>1</span><span>Y</span><span>2</span><span>Y</span><span>3</span><span>...Y</span><span>n</span></p></cell></row><row><cell><p><span>The nonterminal</span><span> X</span><span> is declared equivalent to the concatenation of the symbols</span><span> Y</span><span>1</span><span>Y</span><span>2</span><span>Y</span><span>3</span><span>...Y</span><span>n</span><span>. The production means that anywhere where we encounter</span><span> X</span><span>, we may replace it by the string</span><span> Y</span><span>1</span><span>Y</span><span>2</span><span>Y</span><span>3</span><span>...Y</span><span>n</span><span>.</span><span> Eventually we will have a string containing nothing that can be expanded further, i.e., it will consist of only terminals. Such a string is called a</span><span style="italic"> sentence</span><span>. In the context of programming languages, a sentence is a syntactically correct and complete program.</span></p></cell></row><row><cell><p><span style="italic">derivation</span></p></cell><cell><p><span>a sequence of applications of the rules of a grammar that produces a finished string of terminals. A</span><span style="italic"> leftmost derivation</span><span> is where we always substitute for the leftmost nonterminal as we apply the rules (we can similarly define a rightmost derivation). A derivation is also called a</span><span style="italic"> parse</span><span>.</span></p></cell></row><row><cell><p><span style="italic">start symbol</span></p></cell><cell><p><span>a grammar has a single nonterminal (the start symbol) from which all sentences derive:</span></p></cell></row><row><cell row_span="2" /><cell><p><span>S –&gt; X</span><span>1</span><span>X</span><span>2</span><span>X</span><span>3</span><span>...X</span><span>n</span></p></cell></row><row><cell><p><span>All sentences are derived from</span><span> S</span><span> by successive replacement using the productions of the grammar.</span></p></cell></row><row><cell><p><span style="italic">null symbol</span></p></cell><cell><p><span>e</span></p></cell><cell><p><span>it is sometimes useful to specify that a symbol can be replaced by nothing at all. To indicate this, we use the null symbol</span><span> e</span><span> , e.g.,</span><span> A –&gt; B |</span><span> e</span><span>.</span></p></cell></row><row><cell><p><span style="italic">BNF</span></p></cell><cell /><cell><p><span>a way of specifying programming languages using formal grammars and production rules with a particular form of notation (Backus­Naur form).</span></p></cell></row></table><anchors id="page3"></anchors><p><span>A few grammar exercises to try on your own (The alphabet in each case is</span><span> {a,b}.)</span></p><ul><li><p><span>o</span><span> Define a grammar for the language of strings with one or more a's followed by zero or more b's.</span></p></li><li><p><span>o</span><span> Define a grammar for even­length palindromes.</span></p></li><li><p><span>o</span><span> Define a grammar for strings where the number of a's is equal to the number b's.</span></p></li><li><p><span>o</span><span> Define a grammar where the number of a's is not equal to the number b's. (Hint: think about it as two separate cases...)</span></p></li></ul><p><span>(Can you write regular expressions for these languages? Why or why not?)</span></p><p><span style="bold">Parse Representation</span></p><p><span>In working with grammars, we can represent the application of the rules to derive a sentence in two ways. The first is a derivation as shown earlier for "This is a university" where the rules are applied step­by­step and we substitute for one nonterminal at a time. Think of a derivation as a history of how the sentence was parsed because it not only includes which productions were applied, but also the order they were applied (i.e., which nonterminal was chosen for expansion at each step). There can many different derivations for the same sentence (the leftmost, the rightmost, and so on).</span></p><p><span>A</span><span style="italic"> parse tree</span><span> is the second method for representation. It diagrams how each symbol derives from other symbols in a hierarchical manner. Here is a parse tree for "This is a</span> <span>university":</span></p><p><span>s</span> <span>subject</span> <span>v-p</span></p><p><span>object</span> <span>This</span></p><p><span>verb</span> <span>a</span> <span>noun</span> <span>is</span></p><p><span>university</span></p><p><span>Although the parse tree includes all of the productions that were applied, it does not encode the order they were applied. For an unambiguous grammar (we’ll define ambiguity in a minute), there is exactly one parse tree for a particular sentence.</span></p><p><span style="bold">More Definitions</span></p><p><span>Here are some other definitions we will need, described in reference to this example grammar:</span></p><table columns="3" rows="3"><row><cell><p><span>S</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>AB</span></p></cell></row><row><cell><p><span>A</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>Ax | y</span></p></cell></row><row><cell><p><span>B</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>z</span></p></cell></row></table><anchors id="page4"></anchors><p><span style="italic">alphabet</span></p><p><span>The alphabet is</span><span> {S, A, B, x, y, z}.</span><span> It is divided into two disjoint sets. The</span><span style="italic"> terminal alphabet</span><span> consists of terminals, which appear in the sentences of the language:</span><span> {x, y, z}</span><span>. The remaining symbols are the</span><span style="italic"> nonterminal alphabet</span><span>; these are the symbols that appear on the left side of productions and can be replaced during the course of a derivation:</span><span> {S, A, B}.</span><span> Formally, we use</span><span style="bold"> V</span><span> for the alphabet,</span><span style="bold"> T</span><span> for the terminal alphabet and</span><span style="bold"> N</span><span> for the nonterminal alphabet giving us:</span><span style="bold"> V</span><span> =</span><span style="bold"> T</span><span> ¨</span><span style="bold"> N</span><span>, and</span><span style="bold"> T</span><span> ˙</span><span style="bold"> N</span><span> =</span><span> ˘</span><span> .</span></p><p><span>The convention used in our lecture notes are a sans­serif font for grammar elements, lowercase for terminals, uppercase for nonterminals, and underlined lowercase (e.g.,</span><span style="underline"> u</span><span>,</span><span style="underline"> v</span><span>) to denote arbitrary strings of terminal and nonterminal symbols (possibly null). In some textbooks, Greek letters are used for arbitrary strings of terminal and nonterminal symbols (e.g.,</span><span> a, b</span><span> )</span></p><p><span style="italic">context­free grammar</span></p><p><span>To define a language, we need a set of productions, of the general form:</span><span style="underline"> u</span><span> –&gt;</span><span style="underline"> v</span><span>. In a</span><span style="italic"> context­free grammar</span><span>,</span><span style="underline"> u</span><span> is a single nonterminal and</span><span style="underline"> v</span><span> is an arbitrary string of terminal and nonterminal symbols. When parsing, we can replace</span><span style="underline"> u</span><span> by</span><span style="underline"> v</span><span> wherever it occurs. We shall refer to this set of productions symbolically as</span><span style="bold"> P.</span></p><p><span style="italic">formal grammar</span></p><p><span>We formally define a grammar as a 4­tuple {</span><span>S,</span><span style="bold"> P, N, T</span><span>}.</span><span> S</span><span> is the start symbol (with</span><span> S</span><span> ˛</span><span style="bold"> N</span><span>),</span><span style="bold"> P</span><span> is the set of productions, and</span><span style="bold"> N</span><span> and</span><span style="bold"> T</span><span> are the nonterminal and terminal alphabets. A sentence is a string of symbols in</span><span style="bold"> T</span><span> derived from</span><span> S</span><span> using one or more applications of productions in</span><span style="bold"> P.</span><span> A string of symbols derived from</span><span> S</span><span> but possibly including nonterminals is called a</span><span style="italic"> sentential form</span><span> or a</span><span style="italic"> working string</span><span>.</span></p><p><span>A production</span><span style="underline"> u</span><span> –&gt;</span><span style="underline"> v</span><span> is used to replace an occurrence of</span><span style="underline"> u</span><span> by</span><span style="underline"> v</span><span>. Formally, if we apply a production p</span><span> ˛</span><span style="bold"> P</span><span> to a string of symbols</span><span style="underline"> w</span><span> in</span><span style="bold"> V</span><span> to yield a new string of symbols</span><span style="underline"> z</span><span> in</span><span style="bold"> V</span><span>, we say that</span><span style="underline"> z</span><span> derived from</span><span style="underline"> w</span><span> using p, written as follows:</span><span style="underline"> w</span><span> =&gt;</span><span>p</span><span style="underline"> z</span><span>. We also use:</span></p><ul><li><p><span style="underline">w</span><span> =&gt;</span><span style="underline"> z</span></p><ul><li><p><span style="underline">z</span><span> derives from</span><span style="underline"> w</span><span> (production unspecified)</span></p></li></ul></li><li><p><span style="underline">w</span><span> =&gt;</span><span>*</span><span style="underline"> z</span></p><ul><li><p><span style="underline">z</span><span> derives from</span><span style="underline"> w</span><span> using zero or more productions</span></p></li></ul></li><li><p><span style="underline">w</span><span> =&gt;</span><span>+</span><span style="underline"> z</span></p></li></ul><ul><li><p><span style="underline">z</span><span> derives from</span><span style="underline"> w</span><span> using one or more productions</span></p></li></ul><p><span style="italic">equivalence</span></p><p><span>The language L(G) defined by grammar G is the set of sentences derivable using G. Two grammars G and G' are said to be</span><span style="italic"> equivalent</span><span> if the languages they generate, L(G) and L(G'), are the same.</span></p><anchors id="page5"></anchors><p><span style="bold">Grammar Hiearchy</span></p><p><span>We owe a lot of our understanding of grammars to the work of the American linguist Noam Chomsky (yes, the Noam Chomsky known for his politics). There are four categories of formal grammars in the</span><span style="italic"> Chomsky Hierarchy</span><span>, they span from Type 0, the most general, to Type 3, the most restrictive. More restrictions on the grammar make it easier to describe and efficiently parse, but reduce the expressive power.</span></p><p><span>Type 0: free or unrestricted grammars</span></p><p><span>These are the most general. Productions are of the form</span><span style="underline"> u</span><span> –&gt;</span><span style="underline"> v</span><span> where both</span><span style="underline"> u</span><span> and</span><span style="underline"> v</span><span> are arbitrary strings of symbols in</span><span style="bold"> V</span><span>, with</span><span style="underline"> u</span><span> non­null. There are no restrictions on what appears on the left or right­hand side other than the left­hand side must be non­empty.</span></p><p><span>Type 1: context­sensitive grammars</span></p><p><span>Productions are of the form</span><span style="underline"> u</span><span>X</span><span style="underline">w</span><span> –&gt;</span><span style="underline"> uvw</span><span> where</span><span style="underline"> u</span><span>,</span><span style="underline"> v</span><span> and</span><span style="underline"> w</span><span> are arbitrary strings of symbols in</span><span style="bold"> V</span><span>, with</span><span style="underline"> v</span><span> non­null, and</span><span> X</span><span> a single nonterminal. In other words,</span><span> X</span><span> may be replaced by</span><span style="underline"> v</span><span> but only when it is surrounded by</span><span style="underline"> u</span><span> and</span><span style="underline"> w</span><span>. (i.e., in a particular context).</span></p><p><span>Type 2: context­free grammars</span></p><p><span>Productions are of the form</span><span> X–&gt;</span><span style="underline"> v</span><span> where</span><span style="underline"> v</span><span> is an arbitrary string of symbols in</span><span style="bold"> V</span><span>, and</span><span> X</span><span> is a single nonterminal. Wherever you find</span><span> X,</span><span> you can replace with</span><span style="underline"> v</span><span> (regardless of context).</span></p><p><span>Type 3: regular grammars</span></p><p><span>Productions are of the form</span><span> X–&gt; a, X–&gt; aY, or X–&gt;</span><span>e</span><span> where</span><span> X</span><span> and</span><span> Y</span><span> are nonterminals and</span><span> a</span><span> is a terminal. That is, the left­hand side must be a single nonterminal and the right­hand side can be either empty, a single terminal by itself or with a single nonterminal. These grammars are the most limited in terms of expressive power.</span></p><p><span>Every type 3 grammar is a type 2 grammar, and every type 2 is a type 1 and so on. Type 3 grammars are particularly easy to parse because of the lack of recursive constructs. Efficient parsers exist for many classes of Type 2 grammars. Although Type 1 and Type 0 grammars are more powerful than Type 2 and 3, they are far less useful since we cannot create efficient parsers for them. In designing programming languages using formal grammars, we will use Type 2 or context­free grammars, often just abbreviated as CFG.</span></p><p><span style="bold">Issues in parsing context­free grammars</span></p><anchors id="page6"></anchors><p><span>There are several efficient approaches to parsing most Type 2 grammars and we will talk through them over the next few lectures. However, there are some issues that can interfere with parsing that we must take into consideration when designing the</span> <span>grammar. Let’s take a look at three of them: ambiguity, recursive rules, and left­factoring.</span></p><p><span style="bold">Ambiguity</span></p><p><span>If a grammar permits more than one parse tree for some sentences, it is said to be</span><span style="italic"> ambiguous</span><span>. For example, consider the following classic arithmetic expression grammar:</span></p><table columns="3" rows="2"><row><cell><p><span>E</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>E op E | ( E ) | int</span></p></cell></row><row><cell><p><span>op</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>+| - | * | /</span></p></cell></row></table><p><span>This grammar denotes expressions that consist of integers joined by binary operators and possibly including parentheses. As defined above, this grammar is ambiguous because for certain sentences we can construct more than one parse tree. For example, consider the expression</span><span> 10 – 2 * 5</span><span>. We parse by first applying the production</span><span> E –&gt; E op E.</span><span> The parse tree on the left chooses to expand that first</span><span> op</span><span> to</span><span> *,</span><span> the one on the right to</span><span> -.</span><span> We have two completely different parse trees. Which one is correct?</span></p><p><span>E</span></p><p><span>E op *</span></p><p><span>E</span> <span>E </span><br /><img uri="images/0.png" /><span>int 10</span></p><p><span>op -</span> <span>E</span> <span>int 2</span></p><p><span>E </span><br /><span>int 5</span></p><p><span>E </span><br /><span>int 10</span></p><p><span>op -</span> <span>E</span> <span>E </span><br /><span>int</span></p><p><span>op *</span></p><p><span>E </span><br /><span>int</span></p><p><span>5 </span><br /><span>2</span></p><p><span>Both trees are legal in the grammar as stated and thus either interpretation is valid. Although natural languages can tolerate some kind of ambiguity (e.g., puns, plays on words, etc.), it is not acceptable in computer languages. We don’t want the compiler just haphazardly deciding which way to interpret our expressions! Given our expectations from algebra concerning precedence, only one of the trees seems right. The right­hand tree fits our expectation that * "binds tighter" and for that result to be computed first then integrated in the outer expression which has a lower precedence operator.</span></p><p><span>It’s fairly easy for a grammar to become ambiguous if you are not careful in its construction. Unfortunately, there is no magical technique that can be used to resolve all varieties of ambiguity. It is an undecidable problem to determine whether any grammar is ambiguous, much less to attempt to mechanically remove all ambiguity. However, that doesn't mean in practice that we cannot detect ambiguity or do something about it. For programming language grammars, we usually take pains to construct an unambiguous grammar or introduce additional disambiguating rules to throw away the undesirable parse trees, leaving only one for each sentence.</span></p><anchors id="page7"></anchors><p><span>Using the above ambiguous expression grammar, one technique would leave the grammar as is, but add disambiguating rules into the parser implementation. We could code into the parser knowledge of precedence and associativity to break the tie and force the parser to build the tree on the right rather than the left. The advantage of this is that the grammar remains simple and less complicated. But as a downside, the syntactic structure of the language is no longer given by the grammar alone.</span></p><p><span>Another approach is to change the grammar to only allow the one tree that correctly reflects our intention and eliminate the others. For the expression grammar, we can separate expressions into multiplicative and additive subgroups and force them to be expanded in the desired order.</span></p><table columns="3" rows="5"><row><cell><p><span>E</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>E t_op E | T</span></p></cell></row><row><cell><p><span>t_op</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>+| -</span></p></cell></row><row><cell><p><span>T</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>T f_op T | F</span></p></cell></row><row><cell><p><span>f_op</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>* |/</span></p></cell></row><row><cell><p><span>F</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>(E) | int</span></p></cell></row></table><p><span>Terms are addition/subtraction expressions and factors used for multiplication and division. Since the base case for expression is a term, addition and subtraction will appear higher in the parse tree, and thus receive lower precedence.</span></p><p><span>After verifying that the above re­written grammar has only one parse tree for the earlier ambiguous expression, you might thing we were home free, but now consider the expression</span><span> 10 –2 –5.</span><span> The recursion on both sides of the binary operator allows either side to match repetitions. The arithmetic operators usually associate to the left, so by replacing the right­hand side with the base case will force the repetitive matches onto the left side. The final result is:</span></p><table columns="3" rows="5"><row><cell><p><span>E</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>E t_op T | T</span></p></cell></row><row><cell><p><span>t_op</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>+| -</span></p></cell></row><row><cell><p><span>T</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>T f_op F | F</span></p></cell></row><row><cell><p><span>f_op</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>* |/</span></p></cell></row><row><cell><p><span>F</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>(E) | int</span></p></cell></row></table><p><span>Whew! The obvious disadvantage of changing the grammar to remove ambiguity is that it may complicate and obscure the original grammar definitions. There is no mechanical means to change any ambiguous grammar into an unambiguous one (undecidable, remember?) However, most programming languages have only limited issues with ambiguity that can be resolved using ad hoc techniques.</span></p><anchors id="page8"></anchors><p><span style="bold">Recursive productions</span></p><p><span>Productions are often defined in terms of themselves. For example a list of variables in a programming language grammar could be specified by this production:</span></p><p><span>variable_list</span></p><p><span>–&gt;</span> <span>variable | variable_list , variable</span></p><p><span>Such productions are said to be</span><span style="italic"> recursive</span><span>. If the recursive nonterminal is at the left of the right­side of the production, e.g.</span><span> A –&gt;</span><span style="underline"> u</span><span> | A</span><span style="underline">v</span><span>, we call the production</span><span style="italic"> left­recursive</span><span>. Similarly, we can define a</span><span style="italic"> right­recursive</span><span> production:</span><span> A –&gt;</span><span style="underline"> u</span><span> |</span><span style="underline"> v</span><span>A</span><span>. Some parsing techniques have trouble with one or the other variants of recursive productions and so sometimes we have to massage the grammar into a different but equivalent form. Left­recursive productions can be especially troublesome in the top­down parsers (and we’ll see why a bit later). Handily, there is a simple technique for rewriting the grammar to move the recursion to the other side. For example, consider this left­recursive rule:</span></p><p><span>X</span></p><p><span>–&gt;</span> <span>Xa | Xb | AB | C | DEF</span></p><p><span>To convert the rule, we introduce a new nonterminal</span><span> X'</span><span> that we append to the end of all non­left­recursive productions for</span><span> X</span><span>. The expansion for the new nonterminal is basically the reverse of the original left­recursive rule. The re­written productions are:</span></p><table columns="3" rows="2"><row><cell><p><span>X</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>ABX' | CX' | DEFX'</span></p></cell></row><row><cell><p><span>X'</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>aX' | bX' |</span><span> e</span></p></cell></row></table><p><span>It appears we just exchanged the left­recursive rules for an equivalent right­recursive version. This might seem pointless, but some parsing algorithms prefer or even require only left or right recursion.</span></p><p><span style="bold">Left­factoring</span></p><p><span>The parser usually reads tokens from left to right and it is convenient if, upon reading a token, it can make an immediate decision about which production from the grammar to expand. However, this can be trouble if there are productions that have common first symbol(s) on the right side of the productions. Here is an example we often see in programming language grammars:</span></p><p><span>Stmt</span></p><p><span>–&gt;</span> <span>if Cond then Stmt else Stmt</span></p><p><span>| if Cond then Stmt |</span> <span>Other</span></p><p><span>| ....</span></p><anchors id="page9"></anchors><p><span>The common prefix is</span><span> if Cond then Stmt</span><span>. This causes problems because when a parser encounter an “if”, it does not know which production to use. A useful technique called</span><span style="italic"> left­factoring</span><span> allows us to restructure the grammar to avoid this situation. We rewrite the productions to defer the decision about which of the options to choose until we have seen enough of the input to make the appropriate choice. We factor out the common</span> <span>part of the two options into a shared rule that both will use and then add a new rule that picks up where the tokens diverge.</span></p><p><span>Stmt OptElse</span></p><p><span>–&gt; –&gt;</span> <span>if Cond then Stmt OptElse</span></p><p><span>|</span> <span>Other</span></p><p><span>| …</span></p><p><span>else S |</span></p><p><span>e</span></p><p><span>In the re­written grammar, upon reading an “if” we expand first production and wait until</span><span> if Cond then Stmt</span><span> has been seen to decide whether to expand</span><span> OptElse</span><span> to</span><span> else</span><span> or</span><span> e</span><span>.</span></p><p><span style="bold">Hidden left­factors and hidden left recursion</span></p><p><span>A grammar may not appear to have left recursion or left factors, yet still have issues that will interfere with parsing. This may be because the issues are hidden and need to be first exposed via substitution.</span></p><p><span>For example, consider this grammar:</span></p><table columns="3" rows="2"><row><cell><p><span>A</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>da | acB</span></p></cell></row><row><cell><p><span>B</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>abB | daA | Af</span></p></cell></row></table><p><span>A cursory examination of the grammar may not detect that the first and second productions of B overlap with the third. We substitute the expansions for A into the third production to expose this:</span></p><table columns="3" rows="2"><row><cell><p><span>A</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>da | acB</span></p></cell></row><row><cell><p><span>B</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>abB | daA | daf | acBf</span></p></cell></row></table><p><span>This exchanges the original third production of B for several new productions, one for each of the productions for A. These directly show the overlap, and we can then left­factor:</span></p><table columns="3" rows="4"><row><cell><p><span>A</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>da | acB</span></p></cell></row><row><cell><p><span>B</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>aM | daN</span></p></cell></row><row><cell><p><span>M</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>bB | cBf</span></p></cell></row><row><cell><p><span>N</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>A| f</span></p></cell></row></table><p><span>Similarly, the following grammar does not appear to have any left­recursion:</span></p><table columns="3" rows="2"><row><cell><p><span>S</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>Tu | wx</span></p></cell></row><row><cell><p><span>T</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>Sq | vvS</span></p></cell></row></table><p><span>Yet after substitution of S into T, the left­recursion comes to light:</span></p><table columns="3" rows="2"><row><cell><p><span>S</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>Tu | wx</span></p></cell></row><row><cell><p><span>T</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>Tuq | wxq | vvS</span></p></cell></row></table><p><span>If we then eliminate left­recursion, we get:</span></p><anchors id="page10"></anchors><table columns="3" rows="3"><row><cell><p><span>S</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>Tu | wx</span></p></cell></row><row><cell><p><span>T</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>wxqT' | vvST'</span></p></cell></row><row><cell><p><span>T'</span></p></cell><cell><p><span>–&gt;</span></p></cell><cell><p><span>uqT' |</span><span> e</span></p></cell></row></table><p><span style="bold">Programming language case study: ALGOL</span></p><p><span>Algol is of interest to us because it was the first programming language to be defined using a grammar. It grew out of an international effort in the late 1950’s to create a "universal programming language" that would run on all machines. At that time, FORTRAN and COBOL were the prominent languages, with new languages sprouting up all around. Programmers became increasingly concerned about portability of programs and being able to communicate with one another on programming topics.</span></p><p><span>Consequently the ACM and GAMM (Gesellschaft f</span><span>ü</span><span>r angewandte Mathematik und Mechanik) decided to come up with a single programming language that all could use on their computers, and in whose terms programs could be communicated between the users of all machines. Their first decision was not to use FORTRAN as their universal language. This may seem surprising to us today, since it was the most commonly used language back then. However, as Alan J. Perlis, one of the original committee members, puts it:</span></p><p><span>"Today, FORTRAN is the property of the computing world, but in 1957, it was an IBM creation and closely tied to IBM hardware. For these reasons, FORTRAN was unacceptable as a universal language."</span></p><p><span>ALGOL­58 was the first version of the language, followed up very soon after by ALGOL­60, which is the version that had the most impact. As a language, it introduced the following features:</span></p><ul><li><p><span>o</span><span> block structure and nested structures</span></p></li><li><p><span>o</span><span> strong typing</span></p></li><li><p><span>o</span><span> scoping</span></p></li><li><p><span>o</span><span> procedures and functions</span></p></li><li><p><span>o</span><span> call by value, call by reference</span></p></li><li><p><span>o</span><span> side effects (is this good or bad?)</span></p></li><li><p><span>o</span><span> recursion</span></p></li></ul><p><span>It may seem surprising that recursion was not present in the original FORTRAN or COBOL. You probably know that to implement recursion we need a runtime stack to store the activation records as functions are called. In FORTRAN and COBOL, activation records were created at compile time, not runtime. Thus, only one activation record per subroutine was created. No stack was used. The parameters for the subroutine were copied into the activation record and that data area was used for subroutine processing.</span></p><anchors id="page11"></anchors><p><span>The ALGOL report was the first time we see BNF to describe a programming language. Both John Backus and Peter Naur were on the ALGOL committees. They derived this description technique from an earlier paper written by Backus. The technique was adopted because they needed a machine­independent method of description. If one looks at the early definitions of FORTRAN, one can see the links to the IBM hardware. With ALGOL, the machine was not relevant. BNF had a huge impact on programming language design and compiler construction. First, it stimulated a large number of studies on the formal structure of programming languages laying the groundwork for a theoretical approach to language design. Second, a formal syntactic description could be used to drive a compiler directly (as we shall see).</span></p><p><span>ALGOL had a tremendous impact on programming language design, compiler construction, and language theory, but the language itself was a commercial failure. Partly this was due to design decisions (overly complex features, no IO) along with the politics of the time (popularity of Fortran, lack of support from the all­powerful IBM, resistance to BNF).</span></p><p><span style="bold">Bibliography</span></p><p><span>A. Aho, R. Sethi, J. Ullman, Compilers: Principles, Techniques, and Tools. Reading, MA:</span></p><p><span>Addison-Wesley, 1986.</span></p><p><span>J. Backus, “The Syntax and Semantics of the Proposed International Algebraic Language of the Zurich ACM-GAMM Conference,” Proceedings of the International Conference on</span></p><p><span>Information Processing, 1959, pp. 125-132.</span></p><p><span>N. Chomsky, “On Certain Formal Properties of Grammars,” Information and Control, Vol. 2,</span></p><p><span>1959, pp. 137-167.</span></p><p><span>J.P. Bennett, Introduction to Compiling Techniques. Berkshire, England: McGraw-Hill, 1990.</span></p><p><span>D. Cohen, Introduction to Computer Theory. New York: Wiley, 1986.</span></p><p><span>J.C. Martin, Introduction to Languages and the Theory of Computation. New York, NY:</span></p><p><span>McGraw-Hill, 1991.</span></p><p><span>P. Naur, “Programming Languages, Natural Languages, and Mathematics,” Communications</span></p><p><span>of the ACM, Vol 18, No. 12, 1975, pp. 676-683.</span></p><p><span>J. Sammet, Programming Languages: History and Fundamentals. Englewood-Cliffs, NJ:</span></p><p><span>Prentice-Hall, 1969.</span></p><p><span>R.L.Wexelblat, History of Programming Languages. London: Academic Press, 1981.</span></p></root>